package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"regexp"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

var wordRe = regexp.MustCompile("[^a-zA-Z0-9]+")

func toCamel(s string) string {
	parts := wordRe.Split(s, -1)
	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	out := strings.Join(parts, "")
	if out == "" {
		return "Field"
	}
	if out[0] >= '0' && out[0] <= '9' {
		out = "F" + out
	}
	return out
}

type Field struct {
	Name     string
	YAMLName string
	Type     string
}

type TypeDef struct {
	Name   string
	Fields []Field
}

type generator struct {
	defs  map[string]*TypeDef
	order []string
}

func newGenerator() *generator { return &generator{defs: map[string]*TypeDef{}} }

func (g *generator) addDef(t *TypeDef) {
	if _, ok := g.defs[t.Name]; ok {
		return
	}
	g.defs[t.Name] = t
	g.order = append(g.order, t.Name)
}

func (g *generator) genType(name string, v interface{}) string {
	switch vv := v.(type) {
	case map[string]interface{}:
		typeName := toCamel(name)
		td := &TypeDef{Name: typeName}
		keys := make([]string, 0, len(vv))
		for k := range vv {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			val := vv[k]
			fieldName := toCamel(k)
			fieldType := g.genType(typeName+fieldName, val)
			td.Fields = append(td.Fields, Field{Name: fieldName, YAMLName: k, Type: fieldType})
		}
		g.addDef(td)
		return typeName
	case []interface{}:
		if len(vv) == 0 {
			return "[]interface{}"
		}
		elemType := g.genType(name+"Item", vv[0])
		return "[]" + elemType
	case string:
		return "string"
	case bool:
		return "bool"
	case int, int64:
		return "int"
	case float64:
		f := vv
		if float64(int64(f)) == f {
			return "int"
		}
		return "float64"
	case nil:
		return "interface{}"
	default:
		return "interface{}"
	}
}

func (g *generator) render(pkg, topType string) ([]byte, error) {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "package %s\n\n", pkg)
	fmt.Fprintf(buf, "// Code generated by cmd/generate-values; DO NOT EDIT.\n\n")
	for i := len(g.order) - 1; i >= 0; i-- {
		name := g.order[i]
		td := g.defs[name]
		fmt.Fprintf(buf, "type %s struct {\n", td.Name)
		for _, f := range td.Fields {
			fmt.Fprintf(buf, "    %s %s `yaml:\"%s\" json:\"%s\"`\n", f.Name, f.Type, f.YAMLName, f.YAMLName)
		}
		fmt.Fprintf(buf, "}\n\n")
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return out, nil
}

func main() {
	in := flag.String("in", "", "input values.yaml path")
	out := flag.String("out", "", "output go file path")
	pkg := flag.String("pkg", "values", "package name for generated file")
	top := flag.String("type", "Values", "top-level type name")
	flag.Parse()
	if *in == "" || *out == "" {
		fmt.Fprintln(os.Stderr, "-in and -out are required")
		os.Exit(2)
	}
	b, err := ioutil.ReadFile(*in)
	if err != nil {
		fmt.Fprintf(os.Stderr, "read input: %v\n", err)
		os.Exit(1)
	}
	var data interface{}
	if err := yaml.Unmarshal(b, &data); err != nil {
		fmt.Fprintf(os.Stderr, "unmarshal yaml: %v\n", err)
		os.Exit(1)
	}
	var topMap map[string]interface{}
	switch d := data.(type) {
	case map[string]interface{}:
		topMap = d
	case nil:
		topMap = map[string]interface{}{}
	default:
		fmt.Fprintln(os.Stderr, "unsupported top-level YAML shape: must be mapping")
		os.Exit(1)
	}
	g := newGenerator()
	g.genType(*top, topMap)
	src, err := g.render(*pkg, *top)
	if err != nil {
		fmt.Fprintf(os.Stderr, "render: %v\n", err)
		os.Exit(1)
	}
	if err := os.WriteFile(*out, src, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write out: %v\n", err)
		os.Exit(1)
	}
}
