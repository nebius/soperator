package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"regexp"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

var wordRe = regexp.MustCompile("[^a-zA-Z0-9]+")

func toCamel(s string) string {
	parts := wordRe.Split(s, -1)
	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	out := strings.Join(parts, "")
	if out == "" {
		return "Field"
	}
	if out[0] >= '0' && out[0] <= '9' {
		out = "F" + out
	}
	return out
}

type Field struct {
	Name     string
	YAMLName string
	Type     string
}

type TypeDef struct {
	Name   string
	Fields []Field
}

type generator struct {
	defs  map[string]*TypeDef
	order []string
}

func newGenerator() *generator { return &generator{defs: map[string]*TypeDef{}} }

func (g *generator) addDef(t *TypeDef) {
	if _, ok := g.defs[t.Name]; ok {
		return
	}
	g.defs[t.Name] = t
	g.order = append(g.order, t.Name)
}

func (g *generator) genType(name string, v interface{}) string {
	switch vv := v.(type) {
	case map[string]interface{}:
		typeName := toCamel(name)
		td := &TypeDef{Name: typeName}
		keys := make([]string, 0, len(vv))
		for k := range vv {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			val := vv[k]
			fieldName := toCamel(k)
			fieldType := g.genType(typeName+fieldName, val)
			td.Fields = append(td.Fields, Field{Name: fieldName, YAMLName: k, Type: fieldType})
		}
		g.addDef(td)
		return typeName
	case []interface{}:
		if len(vv) == 0 {
			return "[]interface{}"
		}
		elemType := g.genType(name+"Item", vv[0])
		return "[]" + elemType
	case string:
		return "string"
	case bool:
		return "bool"
	case int, int64:
		return "int"
	case float64:
		f := vv
		if float64(int64(f)) == f {
			return "int"
		}
		return "float64"
	case nil:
		return "interface{}"
	default:
		return "interface{}"
	}
}

func (g *generator) render(pkg, topType string, defaultVal interface{}) ([]byte, error) {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "package %s\n\n", pkg)
	fmt.Fprintf(buf, "// Code generated by cmd/generate-values; DO NOT EDIT.\n\n")
	// mutate field Types in defs for image/registry/images to pointer forms so
	// literal generation later produces pointer literals.
	for _, td := range g.defs {
		for i, f := range td.Fields {
			if f.YAMLName == "image" || f.YAMLName == "images" || f.YAMLName == "registry" || f.YAMLName == "repository" || f.YAMLName == "tag" {
				fType := f.Type
				if strings.HasPrefix(fType, "[]") {
					elem := strings.TrimPrefix(fType, "[]")
					if _, ok := g.defs[elem]; ok {
						td.Fields[i].Type = "[]*" + elem
						continue
					}
				} else {
					// if basic string, promote to *string so omitempty can be used
					if fType == "string" {
						td.Fields[i].Type = "*string"
						continue
					}
					if _, ok := g.defs[fType]; ok {
						td.Fields[i].Type = "*" + fType
						continue
					}
				}
			}
		}
	}

	for i := len(g.order) - 1; i >= 0; i-- {
		name := g.order[i]
		td := g.defs[name]
		fmt.Fprintf(buf, "type %s struct {\n", td.Name)
		for _, f := range td.Fields {
			fType := f.Type
			if f.YAMLName == "image" || f.YAMLName == "images" || f.YAMLName == "registry" {
				// add omitempty tag for these fields
				fmt.Fprintf(buf, "    %s %s `yaml:\"%s,omitempty\" json:\"%s,omitempty\"`\n", f.Name, fType, f.YAMLName, f.YAMLName)
			} else {
				fmt.Fprintf(buf, "    %s %s `yaml:\"%s\" json:\"%s\"`\n", f.Name, fType, f.YAMLName, f.YAMLName)
			}
		}
		fmt.Fprintf(buf, "}\n\n")
	}
	if defaultVal != nil {
		topName := toCamel(topType)
		lit := g.literalFor(defaultVal, topName, 1)
		indented := indentLines(lit, "\t")
		fmt.Fprintf(buf, "func NewDefaults() %s {\n", topName)
		fmt.Fprintf(buf, "\treturn %s\n", indented)
		fmt.Fprintf(buf, "}\n\n")
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}
	return out, nil
}

func indentLines(s, prefix string) string {
	lines := strings.Split(s, "\n")
	for i, l := range lines {
		if l != "" {
			lines[i] = prefix + l
		}
	}
	return strings.Join(lines, "\n")
}

func (g *generator) literalFor(v interface{}, goType string, level int) string {
	indent := strings.Repeat("\t", level)
	next := strings.Repeat("\t", level+1)
	if v == nil {
		return "nil"
	}
	// handle pointer types by taking address of the value literal
	if strings.HasPrefix(goType, "*") {
		base := strings.TrimPrefix(goType, "*")
		switch base {
		case "string":
			lit := g.literalFor(v, "string", level)
			return fmt.Sprintf("func() *string { s := %s; return &s }()", lit)
		case "bool":
			lit := g.literalFor(v, "bool", level)
			return fmt.Sprintf("func() *bool { b := %s; return &b }()", lit)
		case "int":
			lit := g.literalFor(v, "int", level)
			return fmt.Sprintf("func() *int { i := %s; return &i }()", lit)
		case "float64":
			lit := g.literalFor(v, "float64", level)
			return fmt.Sprintf("func() *float64 { f := %s; return &f }()", lit)
		default:
			return "&" + g.literalFor(v, base, level)
		}
	}
	if goType == "interface{}" {
		switch vv := v.(type) {
		case string:
			return fmt.Sprintf("%q", vv)
		case bool:
			return fmt.Sprintf("%v", vv)
		case float64:
			if float64(int64(vv)) == vv {
				return fmt.Sprintf("%d", int64(vv))
			}
			return fmt.Sprintf("%v", vv)
		case []interface{}:
			_ = vv
		default:
			return fmt.Sprintf("%#v", v)
		}
	}
	if strings.HasPrefix(goType, "[]") {
		elemType := strings.TrimPrefix(goType, "[]")
		arr, ok := v.([]interface{})
		if !ok {
			return "nil"
		}
		b := &bytes.Buffer{}
		fmt.Fprintf(b, "[]%s{\n", elemType)
		for _, el := range arr {
			fmt.Fprintf(b, "%s%s,\n", next, g.literalFor(el, elemType, level+1))
		}
		fmt.Fprintf(b, "%s}", indent)
		return b.String()
	}
	switch goType {
	case "string":
		if s, ok := v.(string); ok {
			return fmt.Sprintf("%q", s)
		}
		return fmt.Sprintf("%q", fmt.Sprint(v))
	case "bool":
		if b, ok := v.(bool); ok {
			return fmt.Sprintf("%v", b)
		}
		return "false"
	case "int":
		switch n := v.(type) {
		case float64:
			return fmt.Sprintf("%d", int64(n))
		case int:
			return fmt.Sprintf("%d", n)
		default:
			return "0"
		}
	case "float64":
		if f, ok := v.(float64); ok {
			return fmt.Sprintf("%v", f)
		}
		return "0.0"
	default:
		// assume struct type
		m, ok := v.(map[string]interface{})
		if !ok {
			return goType + "{}"
		}
		td, ok := g.defs[goType]
		if !ok {
			return goType + "{}"
		}
		b := &bytes.Buffer{}
		fmt.Fprintf(b, "%s{\n", goType)
		for _, f := range td.Fields {
			if val, exists := m[f.YAMLName]; exists {
				fmt.Fprintf(b, "%s%s: %s,\n", next, f.Name, g.literalFor(val, f.Type, level+1))
			}
		}
		fmt.Fprintf(b, "%s}", indent)
		return b.String()
	}
}

func main() {
	in := flag.String("in", "", "input values.yaml path")
	out := flag.String("out", "", "output go file path")
	pkg := flag.String("pkg", "values", "package name for generated file")
	top := flag.String("type", "Values", "top-level type name")
	flag.Parse()
	if *in == "" || *out == "" {
		fmt.Fprintln(os.Stderr, "-in and -out are required")
		os.Exit(2)
	}
	b, err := os.ReadFile(*in)
	if err != nil {
		fmt.Fprintf(os.Stderr, "read input: %v\n", err)
		os.Exit(1)
	}
	var data interface{}
	if err := yaml.Unmarshal(b, &data); err != nil {
		fmt.Fprintf(os.Stderr, "unmarshal yaml: %v\n", err)
		os.Exit(1)
	}
	var topMap map[string]interface{}
	switch d := data.(type) {
	case map[string]interface{}:
		topMap = d
	case nil:
		topMap = map[string]interface{}{}
	default:
		fmt.Fprintln(os.Stderr, "unsupported top-level YAML shape: must be mapping")
		os.Exit(1)
	}
	g := newGenerator()
	g.genType(*top, topMap)
	src, err := g.render(*pkg, *top, topMap)
	if err != nil {
		fmt.Fprintf(os.Stderr, "render: %v\n", err)
		os.Exit(1)
	}
	if err := os.WriteFile(*out, src, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write out: %v\n", err)
		os.Exit(1)
	}
}
